ofekwa

=============================
=      File description     =
=============================
ListWrapper - A simpler LinkedList class that lets the user use only some operations,
including: add, search, remove, isEmpty, pop, getFirst.


=============================
=          Design           =
=============================
There was nothing special in the design this time, I (as instructed) used the simple set
interface that defines the methods every set must have. In addition I wrote an abstract
class, the simple hash set, that is a sort of template for the closed & open hash set
that extends it.

=============================
=  Implementation details   =
=============================
OpenHashSet, table - For its table I used an array of ListWrapper - this way I can use most
of the operation supported in LinkedList, but with friendlier and propose designed api.

ClosedHashSet, deleting mechanism - I first of all checked if the desired value was in the
set, if not - I stop deleting and return false. else - I check if the deletion will require
a reHash - if so: I rehash before the deletion. then I start probing to find the value I want
to delete, until I find it, then I just remove it and update the array representing all the cells
that were deleted (that is useful to mark deleted cells, for other methods also).

In the absract SimpleHashSet I implemented everything that was in common between the closed & open hash sets
and kept everything else abstract.

In the CollectionFacadeSet, I implemented the SimpleSet interface as required, and to avoid duplications upon
constructing a set from a already filled list or a collection that allows duplicates - I used predicate (that
is built in java syntax since java 8). It is a syntax similar to python's lambda. It allowed me to remove
easily duplicates from the collection by removing every elements what appears more than once.


=============================
=      Other Questions      =
=============================
--Analysis results--
 In the analysis I benchmarked 5 implementations of data structures: my own
closed & open hash sets, and java's hash set, tree set and linked list.
I noticed that the open hash set had a bad result in data1 - similar to linked list. I think this
is thanks to similar hashes of the values, causing big chains - like one of a linked list.
The closed hash set had significantly worse results - in this case I think the add method
had to probe a lot before settling on a place to insert the value.

in comparison - the tree and hash sets did a lot better (3 orders of magnitude better).
Compared to others - the linked list is slow data structure, in all areas.
by contrast - the java's hash set is a fast data structure on all areas, as expected,
it was written by oracle. In the benchmarks I did, the tree set's performance as similar
to the hash set, but with worse performance (at the same order of magnitude) - the hash set
is better in add, remove, contains but doesn't keep order of elements (unlike tree).

When comparing my own implementation - overall the open hash set was better - it had better
data loading times (significantly) and a tiny bit worse contain performance. Only in the
case the program will need to access a lot of values in short times I will prefer the closed
hash set - otherwise the open is better.

It was no surprise the java's hash set was a very fast data structure, I expected professional
algorithm writers and programmers from oracle's r&d team could do a better job than I did in few hours.
But it was surprising by how much they had the upper hand, my implementation requires a vast
optimization.


--Warm-up details--
In the warm up I iterated 2000 times on the 'contain' tests, and data.length / 4
in the loading of the data files. I decided on these values because If Increased them, there was no
big change in the benchmark but it extended running times drastically.



